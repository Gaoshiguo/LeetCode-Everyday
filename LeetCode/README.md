
## LeetCode每日一题
[leetcode001](https://leetcode-cn.com/problems/two-sum/)

* 001：题目大致描述如下：在一个数组中，找到两数相加之和等于目标值target的两个数，最后返回这两个数在数组中的位置。  

**思路一：暴力解决，循环遍历两遍（算法时间复杂度O(N^2)，空间复杂度O（1））**  

**思路二：使用哈希表（算法时间复杂度O（n）,空间复杂度O（n））**  

* 002：题目大致描述如下：求两数相加之和，两个数字分别用两个链表按位数倒序排列，如：325，用链表表示为：5—>2->3,使用链表将各位数相加，得到的结果也应当是两数之和。如：532+652=1184,2->3->5 + 2->5->6 = 4->8->1->1  

[leetcode002](https://leetcode-cn.com/problems/add-two-numbers/) 

**思路一：使用加法器的原理，将个位数分别相加，每一位上大于10的取模向前进位（算法时间复杂度O（n），以内存换空间）**

* 003：题目大致描述如下：你找出其中不含有重复字符的最长子串的长度。例如：—_输入"abcabcbb"，无重复字符的最长子串是 "abc"，所以其长度为 3.又例如："pwwkew"因为无重复字符的最长子串是 "wke"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。要求字串连续不间断。_

[leetcode003](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) 

**思路一：从首位开始将字符存储在临时数组tem_array中，依次查看判断后面字符是否在临时数组中出现过，如果没有出现就将这个字符添加到临时数组中，继续向下查找，否则就跳出本次循环，同时记录此次查找临时数组的长度length，在下一次跳出循环时，比较tem_array的长度与length的长度谁大，谁大就用谁代表最长字串的长度** 

[leetcode004](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/) 

* 004题目大致描述如下：给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))
例如：nums1 = [1, 3]，nums2 = [2]则中位数是 2.0，nums1 = [1, 2]，nums2 = [3, 4]，则中位数是 (2 + 3)/2 = 2.5

**思路一：先将两个有序数组合并成一个有序数组，在寻找中位数。注意时间复杂度，由于都是有序数组，所以不必使用双循环来实现合并，从而降低时间复杂度，达到题目要求**

[leetcode005](https://leetcode-cn.com/problems/longest-palindromic-substring/)   
* 004题目大致描述如下：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。  
例如：  
- `输入: "babad"`
- `输出: "bab"`
- `注意: "aba" 也是一个有效答案。`

有关回文子串的解释，可以在百度中详细了解![链接如下](https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin)

**思路一：`中心扩散法`:依次遍历每一个字符，并以该字符为中心，向两边扩散，回文串是一个中心对称结构的字串，扩散时主要比对左右两侧字符是否一样，如果一样继续向外扩散，如果不一样，退出对该字符的比对，并记录下子串的长度，然后开始下一个字符的扩散，知道找到最长的回文子串**

**思路二：`动态规划法`:**
初始状态  - dp[i][i]=1; //单个字符是回文串  - dp[i][i+1]=1 if s[i]=s[i+1]; //连续两个相同字符是回文串

**思路三：`中心扩散反转法`:这个方法与中心扩散法类似，只不过将比对的过程改为反转字符子串，因为回文子串是一个中心对称结构的，因此反转后也应当与原来一样**

